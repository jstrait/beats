#!/usr/bin/env ruby

$:.unshift File.dirname(__FILE__)
require "rubygems"
require "optparse"
require "yaml"
require "wavefile"
require "lib/song"
require "lib/songparser"
require "lib/songoptimizer"
require "lib/songsplitter"
require "lib/kit"
require "lib/pattern"
require "lib/track"
require "lib/wavefileextended"

class Beats
  BEATS_VERSION = "1.2.0a"
  SAMPLE_RATE = 44100
  OPTIMIZED_PATTERN_LENGTH = 4

  def parse_options
    options = {:split => false, :pattern => nil}

    optparse = OptionParser.new do |opts|
      opts.on('-s', '--split', "Save each track to an individual wave file") do
        options[:split] = true
      end

      opts.on('-p', '--pattern PATTERN_NAME', "Output a single pattern instead of the whole song" ) do |p|
        options[:pattern] = p
      end
    
      opts.on('-v', '--version', "Display version number and exit") do
        puts "BEATS v#{BEATS_VERSION}"
        exit
      end
    
      opts.on( '-h', '--help', "Display this screen and exit" ) do
        puts opts
        exit
      end
    end
    optparse.parse!
  
    return options
  end

  def save_wave_file(file_name, num_channels, bits_per_sample, sample_data)
    output = WaveFileExtended.new(num_channels, SAMPLE_RATE, bits_per_sample)
    output.sample_data = sample_data
    output.save(file_name)
    return output.duration
  end

  def run()
    start = Time.now

    options = parse_options
    input_file_name = ARGV[0]
    output_file_name = ARGV[1]

    if(input_file_name == nil)
      ARGV[0] = '-h'
      parse_options()
    end

    if(output_file_name == nil)
      output_file_name = File.basename(input_file_name, File.extname(input_file_name)) + ".wav"
    end

    begin
      song_parser = SongParser.new()
      song = song_parser.parse(File.dirname(input_file_name), YAML.load_file(input_file_name))
      song_optimizer = SongOptimizer.new()

      if(options[:split])
        if(true)
          puts "A"
          song_splitter = SongSplitter.new()
          split_songs = song_splitter.split(song)
          split_songs.each do |split_song|
            if(options[:pattern] == nil)
              split_song = song_optimizer.optimize(split_song, OPTIMIZED_PATTERN_LENGTH)
            end

            puts "#{split_song.to_yaml()}"
            puts "\n\n\n\n\n"
            duration = split_song.write_to_file(output_file_name, options[:pattern])
          end
        else
          puts "B"
          sample_data = song.sample_data(options[:split], options[:pattern])

          duration = nil
          sample_data.keys.each {|track_name|
            extension = File.extname(output_file_name)
            file_name = File.basename(output_file_name, extension) + "-" + File.basename(track_name.to_s, extension) + extension

            duration = save_wave_file(file_name,
                                      song.num_channels,
                                      song.bits_per_sample,
                                      sample_data[track_name])
          }
        end
      else
        if(options[:pattern] == nil)
          song = song_optimizer.optimize(song, OPTIMIZED_PATTERN_LENGTH)
        end

        duration = song.write_to_file(output_file_name, options[:pattern])
      end

      puts "Done! Time to run: #{Time.now - start}"
      #puts "#{duration[:minutes]}:#{duration[:seconds].to_s.rjust(2, '0')} of audio saved to #{output_file_name} in #{Time.now - start} seconds."
    rescue Errno::ENOENT => detail
      puts ""
      puts "Song file '#{input_file_name}' not found."
      puts ""
    rescue SongParseError => detail
      puts ""
      puts "Song file '#{input_file_name}' has an error:"
      puts "  #{detail}"
      puts ""
    rescue StandardError => detail
      puts ""
      puts "An error occured while generating sound for '#{input_file_name}':"
      puts "  #{detail}"
      puts ""
    end
  end
end

beats = Beats.new()
beats.run()